install.packages("slidify")
install.packages("solidify")
install.packages("solidify")
install.packages(c("slidify", "ggplot2", "devtools"))
source("http://bioconductor.org/biocLite.R")
biocLite()
library(ggplot2)
search()
library(slidify)
install.packages(slidify)
install.packages("slidify")
library(devtools)
search()
install_github('slidify', 'ramnathv')
install_github('slidifyLibraries', 'ramnathv')
install.packages("KernSmooth")
library(KernSmooth)
getwd
dir()
x<- c(0.5,0.6)
x
y<- c(1.7,"a")
y
class (x)
class (y)
as.numeric (y)
x<- list(1,"a",True, 1+4i)
z<- list(1, "a", TRUE, 1+4i)
z
m<- matrix(nrow =2, ncol =3)
m
dim(m)
attributes(m)
m<- matrix(1:6, nrow=2, ncol = 3)
m
m<- 1:10
m
dim(m) <- c(2,5)
m
x<- 1:3
y<- 10:12
cbind(x,y)
rbind(x,y)
x<- factor(c("yes", "yes", "no", "yes", "now"))
x
table(x)
unclass (x)
is.na (x)
class(x)
x<- factor(c("yes", "yes", "no", "yes", "no"))
x
levels= c("yes","no")
x
x<- factor(c("yes", "yes", "no", "yes", "no"),
levels= c("yes","no"))
x
is.na(x)
x<- data.frame(foo = 1:4, bar= c(T,T,F,F))
x
ncol(x)
x<- 1:3
names(x)
names(x)<- c("foo","bar", "norf")
x
name(x)
names(x)
y<- data.frame(a=1,b = "a")
dput(y)
structure(list(a=1,
b= structure(1L, .Label= "a",
class = "factor")),
.Names= c("a","b"), row.names = c(NA, -1L),
class= "data.frame")
dputy(y, file= "y.R")
x <- 4L
class(x)
x <- c(4, "a", TRUE)
class(x)
x <- c(1,3, 5)
y <- c(3, 2, 10)
bind(x, y)
cbind(x, y)
x <- list(2, "a", "b", TRUE)
x[[1]]
x <- 1:4
y <- 2
x+y
x <- c(17, 14, 4, 5, 13, 12, 10)
x>=4
x[x >= 11] <- 4
x
hw1 = read.csv('hw1_data.csv')
hw1 <- read.csv(file="/Users/eslamahmed/Documents/Data Sceince/coursera/hw1_data.csv")
names(hw1)
hw1[c(1,2),]
nrow(hw1)
tail(hw1,2)
hw1[47]
hw1[47,1]
is.na (hw1)
sub = subset(hw1, is.na(Ozone))
nrow(sub)
sub= subset(hw1, !is.na(Ozone), select= Ozone)
apply (sub,2 ,mean)
install.packages("swirl")
library(swirl)
install_from_swirl("R Programming")
swirl()
sys.date()
Sys.Date()
x<- c(2, 4, 5)
mean(c(2, 4, 5))
submit()
submit()
boring_function('My first function!')
boring_function
submit()
my_mean<- x/y
submit ()
}
submit()
# You're free to implement the function my_mean however you want, as long as it
submit()
my_mean(4, 5, 10)
my_mean(c(4,5,10))
divisor== 2
submit()
divisor= 2
submit()
x<- num %%divisor
submit()
x<- num %% divisor
submit()
remainder<- x
submit()
num %% divisor
submit()
remainder(5)
remainder((11, 5))
reaminder(11, 5)
remainder(11, 5)
remainder(divisor = 11, num = 5).
remainder(divisor = 11, num = 5)
remainder(4, div = 2)
args(remainder)
# }
submit()
library(swirl)
swirl()
# You can pass functions as arguments to other functions just like you can pass
submit()
}
submit()
}
submit()
func(dat)
subit()
submit()
evaluate <- function (func, dat){
submit()
}
func(dat)
submit()
submit()
func(dat)
sumbit()
submit()
submit()
median(dat)
submit()
}
submit()
}
submit()
#
submit()
# some_function <- function(func){
skip()
evaluate(sd, c(1.4, 3.6, 7.9, 8.8))
evaluate(function(x){x+1}, 6)
evaluate(function(x)[1], c(8, 4, 0))
evaluate(function(x){x[1]}, c(8,4,0))
evaluate(function(x){x[3]}, c(8, 4, 0))
evaulate(function(x){tail(x, n=1)}, c(8, 4, 0))
evaluate(function(x){tail(x, n=1)}, c(8, 4, 0))
paste()
?paste
paste("programming", "is", "fun!")
paste("programming", "is", "Fun!")
paste("Programming", "is", "fun!")
paste("START",...,"STOP")
submit()
telegram(Eslam)
telegram(...== Elsma)
skip()
noun<-args[["noun"]]
submit
submit()
mad_libs(Dubai, crazy, cool)
mad_libs(place, cool, crazy)
info()
skip()
"%p%" <- function(){ "Good"+"job!"
submit()
skip()
sbmit()
enter
exit
}
submit()
"%p%" <- function(){ 'Good'+'job!'
skip()
sbmit()
submit()
"%p%" <- function(){ 'Good'+'job!'
submit()
}
skip()
'I'%p%'love'%p%'R'
"I"%p% "love"%p% "R"
skip9
skip()
head9flags
head(flags)
dim(flags)
class(flags)
cls_list<- lapply(flags, class)
cls_list
class(cls_list)
as.character(cls_list)
cls_lisy<- sapply(flags, class)
cls_vect<- sapply(flags, class)
class(cls_vect)
sum(flags$orange)
flag_colors<- flags [, 11:17]
head(flag_colors, 6)
head(flag_colors)
sum_each<- lapply(flag_colors, sum)
lapply(flag_colors, sum)
sapply(flag_colors, sum)
sapply(flag_colors, mean)
flag_shapes <- flags[, 19:23]
lapply(flag_shapes, range)
sapply(flag_shapes, range)
shape_mat <- sapply(flag_shapes, range)
head(shape_mat)
shape_mat
class(shape_mat)
unique(c(3,4,5,5,5,6,6))
unique_vals<- lapply(flags, unique)
unique_vals
length(unique_vals)
sapply(unique_vals, length)
sapply(flags, unique)
lapply(unique_vals, function(elem) elem[2])
sapply(flags, unique)
vapply(flags, unique, numeric(1))
ok()
sapple(flags, class)
sapply(flags, class)
libray(datasets)
ibrary(datasets)
data(iris)
library(datasets)
data("iris")
data("iris")
?iris
dim(iris)
summary(iris)
sapply(split(iris$Sepal.Length, iris$Species), mean)
class(irirs)
class( "iris")
class(iris)
library(datasets)
data("mtcars")
mtcars
class(mtcars)
dim(mtcars)
tapply(mtcars$hp, split(mtcars$cyl), mean)
sapply(split(mtcars$mpg, mtcars$cyl), mean)
debug(ls)
library(datasets)
data(iris)
library(datasets)
data(iris)
x<- sapply(iris$Species, names)
x
summary(iris)
s<- split(iris$Species, iris)
s
s <- split(iris, iris$Species)
s
sapply(s, mean)
lapply(s, mean)
class(s)
x <- iris$Species[virginica]
x <- iris$Species["virginica"]
x
class(iris$Species)
sapply(iris, mean)
tapply(iris$Sepal.Length, split(iris,iris$Species), mean)
iris$Species
x <- iris$Sepal.Length
y<- iris$Species== "virginica"
y
tapply(x,y, mean)
library(datasets)
data("mtcars")
setwd("~/Documents/Datascience/coursera")
read.table(catchmatrix.r)
setwd("~/Documents/Datascience/coursera/ProgrammingAssignment2")
read.table(catchmatrix.r)
list.files
list.files(path = "~/Documents/Datascience/coursera/ProgrammingAssignment2")
read.table("cachematrix.R" )
read.table(cachematrix.R)
list.files()
data.class(cachematrix.R)
rm(list())
table<- read.table(cachematrix.R header =  FALSE)
table<- read.text("cachematrix.R"" header =  FALSE)
table
table<- read.text("cachematrix.R"" header =  FALSE)
x <- read.text("cachematrix.R"" header =  FALSE)
x <- read.text("cachematrix.R")
source("/Users/eslamahmed/Documents/Datascience/coursera/ProgrammingAssignment2/cachematrix.R")
cachematrix.r
x <- source("/Users/eslamahmed/Documents/Datascience/coursera/ProgrammingAssignment2/cachematrix.R")
x
cachematrix <- read.table("~/Documents/Datascience/coursera/ProgrammingAssignment2/cachematrix.R", header=TRUE, quote="\"")
View(cachematrix)
makeCasheMatrix <- function(x = matrix()) {
inv <- NULL
}
makeCasheMatrix <- function (x = matrix()) {
inv <- NULL
set <- function (y){
x <<- y
inv <<- NULL
}
get <- function () x
setInverse <- function(solveMatrix) inv<<-
getInverse <- function () inv
list(set= set, get= get, setInverse = setInverse, getInverse = getInverse)
}
cacheSolve <- function(x, ...) {
inv <- x$ getInverse ()
if (!is.null(inv)){
message ("getting cashed data")
return(inv)
}
data <- x$get()
inv <- solve (data)
x$setInverse (inv)
inv
}
x <- 1: 20
makeCasheMatrix(x)
## A pair of functions that cache the inverse of a matrix.
## This function creates a special "matrix" object that can cache its inverse.
makeCasheMatrix <- function (x = matrix()) {
inv1 <- NULL
set <- function (y){
x <<- y
inv <<- NULL
}
get <- function () x
set_inv <- function(inv) set_inv <<- inv1
get_inv <- function () inv
list(set= set, get= get, set_inv = set_inv, get_inv = get_inv)
}
## This function computes the inverse of the special "matrix" returned by makeCacheMatrix above.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv1 <- x$ get_inv ()
if (!is.null(inv1)){
message ("getting cashed data")
return(inv1)
}
data <- x$get()
inv2 <- solve (data)
x$set_inv (inv2)
inv 2
}
## This function computes the inverse of the special "matrix" returned by makeCacheMatrix above.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv1 <- x$ get_inv ()
if (!is.null(inv1)){
message ("getting cashed data")
return(inv1)
}
data <- x$get()
inv <- solve (data)
x$set_inv (inv)
inv 2
}
## This function computes the inverse of the special "matrix" returned by makeCacheMatrix above.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv1 <- x$ get_inv ()
if (!is.null(inv1)){
message ("getting cashed data")
return(inv1)
}
data <- x$get()
inv <- solve (data)
x$set_inv (inv)
inv
}
> m <- makeCacheMatrix()
m <- makeCacheMatrix()
> m <- makeCasheMatrix()
m <- makeCasheMatrix()
m$set(matrix(c(0,2,2,0),2,2))
m$get()
cacheSolve(m)
